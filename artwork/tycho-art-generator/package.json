{
    "name": "tycho-art-generator",
    "version": "1.0.0",
    "title": "Tycho Art Generator",
    "description": "Art Style inspired by [Tycho a.k.a. ISO50](https://iso50.com/), which usually has a \"sunset\" composition.\n\n*Note: You MAY NOT use this to make NTFs.*",
    "author": {
        "name": "Christopher Kirk-Nielsen",
        "avatar": "https://assets.codepen.io/209459/internal/avatars/users/default.png?format=auto&height=512&version=1566172924&width=512",
        "web": "https://chriskirknielsen.com/",
        "social": [
            {
                "title": "Codepen",
                "url": "https://codepen.io/chriskirknielsen/"
            },
            {
                "title": "Twitter",
                "url": "https://twitter.com/ckirknielsen"
            },
            {
                "title": "Github",
                "url": "https://github.com/chriskirknielsen"
            }
        ]
    },
    "html": "tycho-art-generator.html",
    "css": [
        "tycho-art-generator.css"
    ],
    "js": "/**\n * v1: Alrighty, it works!\n * v1.1: Added stepped gradients with naïve colour blend\n * Tycho retweeted this, thank you Scott Hansen <3\n * v1.2: Added noise (thanks gggrain) and fixed a few conditions\n */\n\nconst palette = [\n\t'#f2e6da', // Cream\n\t'#f6b827', // Yellow\n\t'#e79c2a', // Light brown\n\t'#f95643', // Orange\n\t'#ff265b', // Hot pink\n\t'#ba276d', // Purple\n\t'#157fd5', // Blue\n\t// '#027939', // Green\n\t'#282423', // Midnight\n\t'#605d58', // Grey\n];\nconst svg = document.querySelector('svg');\nconst ns = svg.getAttribute('xmlns');\n\n/**\n  * Get a random item's index in a provided array.\n  * @param {Array} items\n  * @return {Number}\n*/\nfunction randomIndex(items) {\n  return Math.floor((Math.random() * items.length));\n}\n\n/**\n  * Get a random true or false value.\n  * @return {Boolean}\n  */\nfunction randomBool() {\n\treturn (Math.random() > 0.5);\n}\n\n/**\n  * Get the index of an item in a array that is around the provided index, and not within the optional exclusion list.\n  * @param {Array} items\n  * @param {Number} currentIndex: Index of the item to search around\n  * @param {Number} distance: Distance around the currentIndex to search\n  * @param {Array} exclude: List of items to avoid\n  * @return {Number}: Index of an item close to currentIndex in the distance range and not in the exclusion list\n*/\nfunction getDifferentItem(items, currentIndex, distance = 2, exclude = []) {\n\texclude.push(currentIndex); // Ensure the currentIndex is never used\n\tlet direction = randomBool() ? -1 : 1;\n\tif ((currentIndex + (distance * direction)) >= items.length) { direction *= -1; }\n\telse if ((currentIndex - (distance * direction)) < 0) { direction *= -1; }\n\tlet index = (currentIndex + (distance * direction)) % items.length;\n\tif (index < 0) { index = items.length - Math.abs(index); }\n\twhile (exclude.includes(index)) { index = (index + direction) % items.length; }\n\treturn Math.abs(index);\n}\n\n/**\n * Round a number to a specified decimal precision.\n * @param {Number} number The number to round\n * @param {Number} precision Positive integer  specifying the number of decimal places to show\n * @return {Number} Rounded number\n*/\nfunction round(number, precision = 3) {\n\treturn parseFloat(number.toFixed(precision));\n}\n\n/**\n * Remap a number from one boundary to another.\n * @param {Number} number Initial number to map to a new boundaries\n * @param {Number} in_min The initial number's lower boundary\n * @param {Number} in_max The initial number's upper boundary\n * @param {Number} out_min The final number's lower boundary\n * @param {Number} out_max The final number's upper boundary\n * @return {Number} Remapped number\n */\nfunction remapNumber(number, in_min, in_max, out_min, out_max) {\n\treturn (number - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;\n}\n\n/**\n * Convert an integer in [0,255] to a hexadecimal value.\n * @param {Number} int Integer to convert\n * @return {String} Hexadecimal value\n */\nfunction intToHex(int) {\n\tint = Math.abs(int); // No negatives!\n\tif (int > 255) { int = 255; } // No out of bound values\n    const hex = Math.round(int).toString(16);\n    return hex.padStart(2, '0');\n}\n\n/**\n * Convert a hexadecimal value to an integer.\n * @param {String} hex Hexadecimal to convert\n * @return {Number} Integer value\n */\nfunction hexToInt(hex) {\n\treturn parseInt(hex, 16);\n}\n\n/**\n * Parse a hexadecimal colour string into RGB values.\n * @param {String} hex Integer to convert\n * @return {Object} Individual colour channels converted to [0,255] range set as {r,g,b}\n */\nfunction parseHexCode(hex) {\n\thex = hex.trim();\n\t\n\t// Remove the pound glyph if present\n\tif (hex.substr(0, 1) === '#') {\n\t\thex = hex.substr(1);\n\t}\n\t\n\t// If the hex is in a RGB format instead of RRGGBB, expand it\n\tif (hex.length === 3) {\n\t\tlet hexSplit = hex.split('');\n\t\tlet hexDupe = hexSplit.map(h => `${h}${h}`);\n\t\thex = hexDupe.join('');\n\t}\n\t\n\tconst hexChars = hex.split('');\n\tconst r = hexToInt(`${hexChars[0]}${hexChars[1]}`);\n\tconst g = hexToInt(`${hexChars[2]}${hexChars[3]}`);\n\tconst b = hexToInt(`${hexChars[4]}${hexChars[5]}`);\n\t\n\treturn { r, g, b };\n}\n\n/**\n * Build a hexadecimal colour string from an {r,g,b} object of integers in [0,255]\n * @param {Object} rgb Object with the values for the R, G and B channels\n * @return {String} Hexadecimal value\n */\nfunction buildHexFromRgb(rgb) {\n\tconst { r,g,b } = rgb;\n\treturn `#${intToHex(r)}${intToHex(g)}${intToHex(b)}`;\n}\n\n/**\n * Blend two provided colours into several intermediate colours (naïve and linear RGB blending).\n * @param {String} start Start colour in hexadecimal value\n * @param {String} end End colour in hexadecimal value\n * @param {Number} steps Number of steps between the start and end colours\n * @return {String[]} List of intermediate hexadecimal values\n */\nfunction colorBlender(start, end, steps = 5) {\n\tif (steps < 1) { return []; }\n\t\n\tconst startRgb = parseHexCode(start);\n\tconst endRgb = parseHexCode(end);\n\tlet colors = [];\n\t\n\tfor (var i = 1; i < (steps + 1); i++) {\n\t\tconst weight = i / (steps + 1);\n\t\tconst mixedR = (1 - weight) * startRgb.r + weight * endRgb.r;\n        const mixedG = (1 - weight) * startRgb.g + weight * endRgb.g;\n        const mixedB = (1 - weight) * startRgb.b + weight * endRgb.b;\n\t\tconst newColor = buildHexFromRgb({ r: mixedR, g: mixedG, b: mixedB });\n\t\tcolors.push(newColor);\n\t}\n\t\n\treturn colors;\n}\n\n/**\n * Build a string of SVG gradient color stops that have hard stops.\n * @param {String} start Start colour in hexadecimal value\n * @param {String[]} midpoints List of intermediate hexadecimal values\n * @param {String} end End colour in hexadecimal value\n * @return {String} Markup for a list of SVG gradient stops\n */\nfunction buildSvgSteppedGradientStops(start, midpoints, end) {\n\tconst points = [start, ...midpoints, end];\n\tconst count = points.length;\n\tconst delta = 100 / count; // Distance between each point\n\tlet steps = [];\n\t\n\tpoints.forEach((color, index) => {\n\t\tsteps.push(`<stop stop-color=\"${ color }\" offset=\"${(index * delta)}%\"/>`);\n\t\tsteps.push(`<stop stop-color=\"${ color }\" offset=\"${(index+1) * delta - 0.001}%\"/>`);\n\t});\n\n\treturn steps.join('');\n}\n\n/**\n * Shuffle an array in place\n * @param {Array} a Array to shuffle\n * @return {Array} Shuffled array\n */\nfunction shuffle(a) {\n    var j, x, i;\n    for (i = a.length - 1; i > 0; i--) {\n        j = Math.floor(Math.random() * (i + 1));\n        x = a[i];\n        a[i] = a[j];\n        a[j] = x;\n    }\n    return a;\n}\n\n/**\n * The star of the show\n */\nfunction generateTychoArt() {\n\t// Clear the contents of the SVG\n\twhile (svg.firstChild) { svg.removeChild(svg.firstChild); }\n\t\n\t// Define the poster size\n\tconst w = 1000;\n\tconst ratio = randomBool() ? 4/3 : 1; // Sometimes a square, sometimes a rectangle\n\tconst h = w * ratio;\n\tsvg.setAttribute('width', w);\n\tsvg.setAttribute('height', h);\n\tsvg.setAttribute('viewBox', `0 0 ${w} ${h}`);\n\t\n\t// Set a background colour\n\tconst hasHalfBg = randomBool();\n\tconst hasGradientBg = randomBool();\n\tconst bgIndex = randomIndex(palette);\n\tconst bgIndex2 = getDifferentItem(palette, bgIndex, 1);\n\tconst bgColor = palette[ bgIndex ];\n\tconst bgColor2 = palette[ bgIndex2 ];\n\tconst bgImage = (hasGradientBg) ? `${bgColor} linear-gradient(to bottom, ${bgColor} 0%, ${bgColor2} ${hasHalfBg ? '50%' : '100%'})` : bgColor; // Use a CSS gradient so we don't need to define an SVG gradient and all that…\n\tsvg.style.setProperty('--bg', bgImage);\n\t\n\t// Define lists\n\tlet shapes = [];\n\tlet usedColors = [bgIndex];\n\t\n\t// Set up defs element, we'll add our gradients to this\n\tconst defs = document.createElementNS(ns, 'defs');\n\tsvg.appendChild(defs);\n\t\n\t// Define texture: https://fffuel.co/gggrain/\n\tdefs.innerHTML = `<filter id=\"gggrain-filter\" x=\"-20%\" y=\"-20%\" width=\"140%\" height=\"140%\" filterUnits=\"objectBoundingBox\" primitiveUnits=\"userSpaceOnUse\" color-interpolation-filters=\"sRGB\">\n  <feTurbulence type=\"fractalNoise\" baseFrequency=\"0.75\" numOctaves=\"6\" seed=\"${Math.round(Math.random() * 999)}\" stitchTiles=\"stitch\" x=\"0%\" y=\"0%\" width=\"100%\" height=\"100%\" result=\"turbulence\"></feTurbulence>\n  <feColorMatrix type=\"saturate\" values=\"0\" x=\"0%\" y=\"0%\" width=\"100%\" height=\"100%\" in=\"turbulence\" result=\"colormatrix\"></feColorMatrix>\n  <feComponentTransfer x=\"0%\" y=\"0%\" width=\"100%\" height=\"100%\" in=\"colormatrix\" result=\"componentTransfer\">\n    <feFuncR type=\"linear\" slope=\"3\"></feFuncR>\n    <feFuncG type=\"linear\" slope=\"3\"></feFuncG>\n    <feFuncB type=\"linear\" slope=\"3\"></feFuncB>\n  </feComponentTransfer>\n  <feColorMatrix x=\"0%\" y=\"0%\" width=\"100%\" height=\"100%\" in=\"componentTransfer\" result=\"colormatrix2\" type=\"matrix\" values=\"1 0 0 0 0\n          0 1 0 0 0\n          0 0 1 0 0\n          0 0 0 19 -11\"></feColorMatrix>\n  </filter>`;\n\t\n\tconst rectColorIndex = getDifferentItem(palette, bgIndex, 2, [bgIndex2]);\n\tconst rectColor = palette[ rectColorIndex ];\n\t\n\t// If there is a half-rectangle, create the element and give it the colour above\n\tif (hasHalfBg) {\n\t\tconst rectBg = document.createElementNS(ns, 'rect');\n\t\trectBg.setAttribute('width', '100%');\n\t\trectBg.setAttribute('height', '50%');\n\t\trectBg.setAttribute('x', 0);\n\t\trectBg.setAttribute('y', '50%');\n\t\trectBg.setAttribute('fill', rectColor);\n\t\tsvg.appendChild(rectBg);\n\t\t\n\t\tusedColors.push(rectColorIndex);\n\t}\n\t\n\t/* TRIANGLE */\n\tconst triangleColorIndex = getDifferentItem(palette, bgIndex, 4, usedColors);\n\tconst triangleColorIndex2 = getDifferentItem(palette, triangleColorIndex, 1);\n\tconst triangleColor = palette[ triangleColorIndex ];\n\tconst triangleColor2 = palette[ triangleColorIndex2 ];\n\tconst triangleColorGradientSmooth = `<stop stop-color=\"${ triangleColor }\" offset=\"0%\"/>\n\t\t\t<stop stop-color=\"${ triangleColor2 }\" offset=\"100%\"/>`;\n\tconst triangleColorStepGradientList = colorBlender(triangleColor, triangleColor2, 3);\n\tconst triangleColorStepGradient = buildSvgSteppedGradientStops(triangleColor,triangleColorStepGradientList,triangleColor2);\n\tconst isTriangleGradientStepped = randomBool();\n\tconst triangleColorGradient = `<linearGradient id=\"triangleGradient\" x1=\"0\" x2=\"0\" y1=\"0\" y2=\"100%\">\n\t\t\t${(isTriangleGradientStepped ? triangleColorStepGradient : triangleColorGradientSmooth)}\n\t\t</linearGradient>`;\n\tdefs.innerHTML += triangleColorGradient;\n\tconst isTriangleGradient = (randomBool());\n\tconst triangleFill = (isTriangleGradient) ? 'url(#triangleGradient)' : triangleColor;\n\tconst triangle = document.createElementNS(ns, 'polygon');\n\tconst isTriangleEqui = randomBool();\n\tconst triangleWidth = (isTriangleEqui ? (Math.random() * (w/2)) : Math.random() * w) + w/2;\n\tconst triangleHeightMin = h/3;\n\tconst triangleHeightMax = (triangleWidth * Math.sqrt(3)) / 2; // Equilateral triangle\n\tconst triangleHeight = isTriangleEqui ? triangleHeightMax : triangleHeightMin;\n\tconst triangleCenterOfMass = (triangleWidth * Math.sqrt(3)) / 3; // Distance from side for an equilateral triangle\n\tconst triangleCenterFromBottom = h/2 - triangleCenterOfMass; // Triangle would be visually centered if the center of mass aligned to the middle of the canvas\n\tconst trianglePullUp = (isTriangleEqui && randomBool()) ? triangleCenterFromBottom : 0;\n\tconst triangleTopPointPos = h - triangleHeight - trianglePullUp;\n\ttriangle.setAttribute('points', `${w/2},${ triangleTopPointPos } ${(w/2 + triangleWidth/2)},${h - trianglePullUp} ${(w/2 - triangleWidth/2)},${h - trianglePullUp}`);\n\ttriangle.setAttribute('fill', triangleFill);\n\tshapes.push(triangle);\n\tusedColors.push(triangleColorIndex);\n\t\n\t/* CIRCLE */\n\tlet circleExcludeColors = Array.from(usedColors);\n\tif (hasHalfBg && rectColorIndex) { circleExcludeColors.push(rectColorIndex); }\n\tconst circleColorIndex = getDifferentItem(palette, triangleColorIndex, 2, circleExcludeColors);\n\tconst circleColorIndex2 = getDifferentItem(palette, circleColorIndex, 1, circleExcludeColors);\n\tconst circleColor = palette[ circleColorIndex ];\n\t// const circleColor2 = palette[ circleColorIndex2 ];\n\tconst circleColor2 = palette[ bgIndex ]; // Fade the circle into the background\n\tconst allowCircleGradient = (!isTriangleGradientStepped || !isTriangleGradient); // Don't want both the triangle and the circle to have a gradient\n\tconst isCircleGradient = (!hasGradientBg && randomBool() && allowCircleGradient);\n\tconst isCircleGradientSmooth = (!isTriangleGradientStepped && !hasHalfBg && randomBool()); // Two stepped gradients would be a bit much\n\tconst circleFill = (isCircleGradient) ? 'url(#circleGradient)' : circleColor;\n\tconst circle = document.createElementNS(ns, 'circle');\n\tconst circleRadius = Math.min(Math.max(0.25, Math.random()) * (w/3), triangleHeight);\n\tlet circlePosY = remapNumber(round(Math.random(), 1), 0, 1, 0, h - triangleHeight);\n\tif (Math.abs(circlePosY - h/2) < h/10) { circlePosY = h/2; } // Snap the circle to the center if the position is within 10% of it\n\tconst isCircleGradientOffset = randomBool();\n\tconst circleColorGradientSmooth = `<radialGradient id=\"circleGradient\" cx=\"50%\" cy=\"50%\" r=\"100%\" fx=\"50%\" fy=\"${isCircleGradientOffset ? 100 : 50}%\">\n\t\t\t<stop stop-color=\"${ circleColor }\" offset=\"0%\" stop-opacity=\"0\"/>\n\t\t\t<stop stop-color=\"${ circleColor }\" offset=\"75%\"/>\n\t\t</radialGradient>`;\n\tconst circleColorStepGradientList = colorBlender(circleColor, circleColor2, 3);\n\tconst circleColorStepGradient = `<linearGradient id=\"circleGradient\" x1=\"0\" x2=\"0\" y1=\"0\" y2=\"100%\">\n\t\t\t${ (buildSvgSteppedGradientStops(triangleColor,triangleColorStepGradientList,triangleColor2)) }\n\t\t</linearGradient>`;\n\tconst circleColorGradient = isCircleGradientSmooth ? circleColorGradientSmooth : circleColorStepGradient;\n\tdefs.innerHTML += circleColorGradient;\n\tcircle.setAttribute('r', circleRadius);\n\tcircle.setAttribute('cx', w/2);\n\tcircle.setAttribute('cy', circlePosY);\n\tcircle.setAttribute('fill', circleFill);\n\tcircle.setAttribute('transform', `rotate(${(!isCircleGradientSmooth && randomBool() ? 45 : 0) } ${w/2} ${circlePosY})`);\n\tshapes.push(circle);\n\tusedColors.push(circleColorIndex);\n\n\t// Sometimes the triangle looks better layered under the circle…\n\tif (randomBool() && circlePosY < triangleTopPointPos) { // If the circle's centre is above the top point of the triangle…\n\t\tshapes.reverse();\n\t}\n\t// shuffle(shapes);\n\t\n\t// Append the shapes\n\tfor (let shape of shapes) {\n\t\tsvg.appendChild(shape);\n\t}\n\t\n\t// Add the title\n\tconst text = document.createElementNS(ns, 'text');\n\tlet textColorIndex = getDifferentItem(palette, bgIndex, 2, usedColors);\n\ttext.setAttribute('x', '50%');\n\ttext.setAttribute('y', round(Math.random(), 1) * 100 + 160);\n\ttext.setAttribute('text-anchor', 'middle');\n\ttext.setAttribute('font-size', 160);\n\ttext.setAttribute('font-family', 'Helvetica, sans-serif');\n\ttext.setAttribute('fill', palette[ textColorIndex ]);\n\ttext.setAttribute('textLength', remapNumber(Math.random(), 0, 1, w * 0.6, w * 0.9));\n\ttext.setAttribute('lengthAdjust', 'spacingAndGlyphs');\n\ttext.textContent = 'TYCHO';\n\ttext.classList.add('tycho-text');\n\tsvg.appendChild(text);\n\t\n\tconst noiseLayer = document.createElementNS(ns, 'rect');\n\tnoiseLayer.setAttribute('width', '100%');\n\tnoiseLayer.setAttribute('height', '100%');\n\tnoiseLayer.setAttribute('fill', 'transparent');\n\tnoiseLayer.setAttribute('filter', 'url(#gggrain-filter)');\n\tnoiseLayer.setAttribute('opacity', '0.05');\n\tnoiseLayer.style.mixBlendMod = 'overlay';\n\tsvg.appendChild(noiseLayer);\n}\n\ndocument.addEventListener('DOMContentLoaded', generateTychoArt);\ndocument.querySelector('button').addEventListener('click', generateTychoArt);\ndocument.querySelector('input[type=\"checkbox\"]').addEventListener('change', function (e) {\n\tlet show = e.target.checked;\n\tdocument.documentElement.classList.toggle('hide-text', !show);\n});",
    "thumbnail": "thumbnail.png",
    "splash": "splash.png",
    "keywords": [
        "cpc-art-inspired",
        "codepenchallenge",
        "tycho",
        "poster",
        "generator"
    ],
    "original": "https://codepen.io/chriskirknielsen/pen/gOXYQNL",
    "codepen": "https://codepen.io/chriskirknielsen/pen/gOXYQNL"
}