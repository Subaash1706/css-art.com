#!/usr/bin/env node

/**
 * CLI progam (Node.js) to generate an IIFE with a selection of Async CSS loader modules
 */

// read package
const fs = require('fs');
const pack = JSON.parse(fs.readFileSync('package.json', 'utf8'));
const cTable = require('console.table');
const zlib = require('zlib');
const request = require('request');

// CLI
const program = require('commander');

program
    .version(pack.version, '-v, --version')
    .usage('[options] <module, module, ...>')
    .option('-c, --compress', 'compress IIFE using Google Closure Compiler')
    .option('-f, --format [format]', 'IIFE format [wrap|unary|none]', 'none')
    .option('-d, --debug', 'load debug sources (Performance API timings etc.)', 'none')
    .option('-o, --output [output]', 'output to file (otherwise printed to stdout)')
    .option('-m, --modules <modules>', 'modules to load (separated by commas or spaces). "all" for all modules.', function(list) {
        return list.split(/[\s,]+/g);
    });

// help
program.on('--help', function() {
    console.log('')

    var modules = [];
    pack._modules.forEach(function(module) {
        modules.push({
            module: module[0],
            description: module[1]
        });
    });
    console.table(modules);
});

// parse arguments
program.parse(process.argv);

var active_modules = [];
var errors = [];
var all = false;
if (program.modules) {

    program.modules.forEach(function(module) {
        module = module.trim();
        if (module) {
            module = module.toLowerCase();

            if (module === 'all') {
                all = true;
            } else {

                var found;
                pack._modules.forEach(function(_module) {
                    if (module === _module[0]) {
                        found = true;
                    }
                });
                if (!found) {
                    errors.push('\t' + module + ' is not a valid module. See package.json#_modules for a list of valid modules.');
                } else {
                    active_modules.push(module);
                }

            }
        }
    });
}

if (all) {
    active_modules = [];
    pack._modules.forEach(function(mod, i) {
        active_modules.push(mod[0]);
    });
}

if (active_modules.length === 0) {
    console.error('\n\n\tYou did not select any modules.\n\n\tSee --help for a list of available modules.\n\n');
} else if ((active_modules.indexOf('css-loader') === -1 && active_modules.indexOf('js-loader') === -1)) {
    console.error('\n\n\tYou did not select the css-loader or js-loader module.\n\n\tSee --help for a list of available modules.\n\n');
} else {

    if (errors.length) {
        console.error('\n\nErrors:\n' + errors.join('\n') + '\n\n');
    } else {

        var modules = [];

        // add module at correct position
        function add_module(name) {
            var index = 0;
            pack._modules.forEach(function(mod, i) {
                if (mod[0] === name) {
                    index = i;
                }
            });
            modules[index] = name;

            if (name === 'api' || name === 'debug' || name === 'dependency') {
                add_module('event-emitter');
            }

            if (name === 'cache') {
                if (is_active('css-loader')) {
                    add_module('cache-css');
                }
                if (is_active('js-loader')) {
                    add_module('cache-js');
                }
                add_module('event-emitter');
            }

            if (name === 'capture') {
                if (is_active('css-loader')) {
                    add_module('capture-css');
                }
                if (is_active('js-loader')) {
                    add_module('capture-js');
                }
            }
        }


        // event emitter is required for debug
        if (program.debug) {
            add_module('debug');
        }

        // module selected?
        function is_active(name) {
            return active_modules.indexOf(name) !== -1
        }

        pack._modules.forEach(function(module, index) {
            module = module[0];

            if (modules.indexOf(module) === -1) {

                if (['css-loader', 'js-loader'].indexOf(module) !== -1) {
                    if (is_active(module)) {
                        add_module(module);
                    }
                } else if (module === 'regex') {

                    // required dependency
                    if (is_active('dependency') || is_active('capture')) {
                        add_module(module);
                    }

                } else if (module === 'vendor') {

                    // required dependency
                    if (is_active('timing') || is_active('capture-observer')) {
                        add_module(module);
                    }

                } else if (is_active(module)) {

                    if (module === 'inview') {

                        if (!is_active('timing')) {
                            add_module('timing');
                        }

                        add_module(module);
                    } else if (module === 'responsive') {

                        if (!is_active('timing')) {
                            add_module('timing');
                        }

                        add_module(module);
                    } else if (module === 'localstorage') {

                        if (!is_active('cache')) {
                            add_module('cache');
                        }

                        add_module(module);
                    } else if (module === 'cache-api') {

                        if (!is_active('cache')) {
                            add_module('cache');
                        }

                        add_module(module);
                    } else if (module === 'capture') {

                        if (!is_active('capture-insert') && !is_active('capture-observer')) {
                            add_module('capture-insert');
                        }

                        add_module(module);
                    } else {

                        if (module.indexOf('capture-') === 0 && !is_active('capture')) {
                            add_module('capture');
                        }

                        add_module(module);
                    }
                }
            }
        });

        // reindex
        var _modules = [];
        modules.forEach(function(module) {
            if (module) {
                _modules.push(module);
            }
        });
        modules = _modules;

        // add async core
        modules.unshift('async-core');

        // IIFE format
        var format = program.format || 'none';

        // create IIFE
        var iife = [];
        if (format === 'wrap') {
            iife.push('(function(window){');
        } else if (format === 'unary') {
            iife.push('!function(window){');
        }

        // load module sources
        modules.forEach(function(module) {
            var source = fs.readFileSync('dist/' + ((program.debug) ? 'debug/' : '') + module + '.js', 'utf8');
            iife.push(source);
        });

        if (format === 'wrap') {
            iife.push('})(window);');
        } else if (format === 'unary') {
            iife.push('}(window);');
        } else {
            format = 'none';
        }

        iife = iife.join('');

        function output_iife(iife) {

            if (program.output) {
                fs.writeFile(program.output, iife, function(err) {

                    if (err) {
                        console.error('\n\n\tError:');
                        console.error('\tFailed to write to IIFE file ', program.output, '\n\n');
                    } else {

                        var stats = fs.statSync(program.output);

                        zlib.gzip(iife, function(error, gzip) {
                            if (error) {
                                console.error('\n\n\tError:');
                                console.error('\tFailed to gzip for stats. File may be written.\n\n');
                                return;
                            }

                            console.log('\n\n\tIIFE saved\n\n\tModules: ' + modules.join(', ') + '' + ((program.debug) ? '\n\tMode: debug (sources from dist/debug)' : '') + '\n\n\tFile: ' + program.output + '\n\tSize: ' + (stats.size / 1024).toFixed(1) + 'kb (' + stats.size + ' bytes)\n\tSize (gzip): ' + (gzip.length / 1024).toFixed(1) + 'kb (' + gzip.length + ' bytes)\n\n')
                        });

                    }
                });
            } else {
                console.log(iife);
            }
        }

        // add Google Closure compiler compression
        if (program.compress) {

            // externs
            const externs_js = fs.readFileSync('async-css.ext.js', 'utf8');

            request({
                url: "https://closure-compiler.appspot.com/compile",
                method: "POST",
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded"
                },
                form: {
                    'compilation_level': 'ADVANCED_OPTIMIZATIONS',
                    'warning_level': 'QUIET',
                    'language': 'ECMASCRIPT6',
                    'language_out': 'ECMASCRIPT5',
                    'js_externs': externs_js,
                    'js_code': iife,
                    'output_info': 'compiled_code'
                }
            }, function(error, response, body) {

                if (error || response.statusCode !== 200) {
                    console.error('\n\n\tError:');
                    console.error('\tGoogle Closure Compiler API error: ', error, '\n\n');
                } else {
                    output_iife(body.trim());
                }

            });

        } else {
            output_iife(iife);
        }

    }

}