/**
 * IIFE module combination generator
 */
const fs = require('fs');
const md5 = require('md5');
const Combinatorics = require('js-combinatorics');

var cache_modules;

function COMBINE(arr, root) {
    var combinations = [];

    Combinatorics.power(arr).forEach(function(combination) {

        var ignore;

        if (root && combination[0] !== root) {
            ignore = 1;
        }
        if (root === 'async-core') {
            if (combination[1] !== 'async-css' && combination[1] !== 'async-js') {
                ignore = 1;
            }
        }

        if (!ignore) {
            var _combinations = [];
            var primary_index = 0;
            var root_keys = ['async-core'];
            if (combination[1] === 'async-css') {
                root_keys.push('async-css');
            }
            if (combination[1] === 'async-js') {
                root_keys.push('async-js');
            }
            var sub = false;
            var regex, vendor,
                regex_mod, vendor_mod;

            combination.forEach(function(value, index) {
                if (value instanceof Array) {

                    root_keys.push(value[0]);

                    if (value[0] === 'cache') {
                        cache_modules = value.slice(0);
                    }

                    /**/
                    _combinations = _combinations.concat(value);

                    primary_index = _combinations.length;

                    sub = 1;

                } else {

                    if (value === 'regex') {
                        regex = 1;
                    }
                    if (value === 'vendor') {
                        vendor = 1;
                    }
                    if (value === 'dependency' || value === 'capture') {
                        regex_mod = 1;
                    }
                    if (value === 'timing' || value === 'capture-observer') {
                        vendor_mod = 1;
                    }

                    if (!(primary_index in _combinations)) {
                        _combinations[primary_index] = [];
                    }
                    _combinations[primary_index].push(value);
                }
            });

            if (
                (!regex && regex_mod) ||
                (!vendor && vendor_mod)
            ) {
                return;
            }

            if (!sub) {
                var combo = [];
                var skip;
                _combinations.forEach(function(c) {
                    combo = combo.concat(c);
                });
                combinations.push(combo);
            } else {

                var combo = [];
                _combinations.forEach(function(c) {
                    if (typeof c === 'string') {
                        combo.push(c);
                    } else {

                        combo = combo.concat(c);
                    }
                });

                combo = JSON.parse(JSON.stringify(combo));
                COMBINE(combo).forEach(function(c, i) {

                    var missing_root_key;
                    if (c.indexOf('cache-update') !== -1 && c.indexOf('xhr') === -1) {
                        missing_root_key = 1; // XHR required for update
                    } else if (c.indexOf('cache') !== -1) {

                        // other cache modules?
                        var other = [];
                        cache_modules.forEach(function(key) {
                            if (key !== 'cache' && c.indexOf(key) !== -1) {
                                other.push(key);
                            }
                        });
                        if (other.length === 0) {
                            missing_root_key = 1; // cache only not required
                        }
                        if (other.length === 1 && other[0] === 'xhr') {
                            missing_root_key = 1; // cache+xhr not required
                        }
                    }

                    root_keys.forEach(function(rk) {
                        if (!missing_root_key) {
                            if (c.indexOf(rk) === -1) {
                                missing_root_key = 1;
                            }
                        }
                    });

                    if (!missing_root_key) {
                        combinations.push(c);
                    }
                });

            }
        }
    });

    return combinations;
}

module.exports = function(arr, root) {

    var key = md5(JSON.stringify([arr, root]));

    try {
        var cache = fs.readFileSync('iife-combinations-cache.json', 'utf8');
        if (cache) {
            cache = JSON.parse(cache);
            if (typeof cache === 'object' && key in cache) {
                return cache[key];
            }
        }
    } catch (e) {

    }

    var combinations = COMBINE(arr, root);
    var cache = {};
    cache[key] = combinations;

    fs.writeFileSync('iife-combinations-cache.json', JSON.stringify(cache), 'utf8');

    return combinations;
};